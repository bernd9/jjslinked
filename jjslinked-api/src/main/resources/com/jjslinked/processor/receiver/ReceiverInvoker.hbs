package {{invoker.packageName}};

import java.util.*;
import java.util.stream.*;
import java.lang.reflect.Method;
import java.lang.annotation.Annotation;
import com.jjslinked.*;
import com.jjslinked.model.*;

public class {{invoker.simpleName}} {

    private static final Method METHOD_TO_INVOKE = getMethodToInvoke();

    private static final List<? extends Annotation> METHOD_ANNOTATIONS = Arrays.asList({{#iterate methodToInvoke.annotationClasses ", "}}{{.}}.class{{/iterate}})
        .stream().map(c -> METHOD_TO_INVOKE.getAnnotation(c)).collect(Collectors.toList());

    private static final List<Class<?>> PARAMETER_TYPES = Arrays.asList({{#iterate methodToInvoke.parameterTypes ", "}}{{.}}.class{{/iterate}});

    private static final MethodContext METHOD_CONTEXT = MethodContext.builder()
        .annotations(METHOD_ANNOTATIONS)
        .declaringClass({{methodToInvoke.declaringClass.qualifiedName}}.class)
        .parameterTypes(PARAMETER_TYPES)
        .build();

    private static ParameterProvider DEFAULT_PROVIDER = null; // TODO


    public void onMessage(ClientMessage message, ApplicationContext applicationContext) throws Exception {
        if (message.getTargetClass().equals({{methodToInvoke.declaringClass.qualifiedName}}.class)
            && message.getMethodName().equals("{{methodToInvoke.name}}")
            && message.getParameterTypes().equals(Arrays.asList(METHOD_TO_INVOKE.getParameterTypes()))) {
                invoke(message, applicationContext);
            }
    }

    public void invoke(ClientMessage message, ApplicationContext applicationContext) throws Exception  {
        {{methodToInvoke.declaringClass.qualifiedName}} bean = applicationContext.getBean({{methodToInvoke.declaringClass.qualifiedName}}.class);
        METHOD_TO_INVOKE.invoke(bean, prepareArgs(message, applicationContext));
    }

    private Object[] prepareArgs(ClientMessage message, ApplicationContext applicationContext) {
        return null;
    }

    private static Method getMethodToInvoke() {
        try {
            return {{methodToInvoke.declaringClass.qualifiedName}}.class.getMethod("{{methodToInvoke.name}}"
            {{#methodToInvoke.parameterTypes}}
            , {{.}}.class
            {{/methodToInvoke.parameterTypes}}
            );
         } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
         }
    }



}